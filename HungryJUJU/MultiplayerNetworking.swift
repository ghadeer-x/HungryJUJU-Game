//
//  MultiplayerNetworking.swift
//  HungryJUJU
//
//  Created by Ghadeer Alkhathlan on 1/8/17.
//  Copyright Â© 2017 Ghadeer Alkhathlan. All rights reserved.
//



import GameKit

enum MultiplayerGameSatate: Int {
    case WaitingForMatch
    case WaitingForRandomNumber
    case WaitingForStart
    case Playing
    case Done
}

/***/
// the messages types and structuers for eeach of the messages you'll be sending back and fourth by adding the following
// each structure represents a type of message your game will sendto the other device
enum MessageType: Int {
    case RandomNumber
    case GameBegin
    case Move
    case Scores
    case GameOver
}

struct Message {
    let messageType: MessageType
}

struct MessageRandomNumber {
    let message: Message
    let randomNumber: UInt32
}

struct MessageGameBegin {
    let message: Message
}
struct MessageMove {
    let message: Message
    let x: CGFloat
}
struct MessageLapComplete {
    let message: Message
}
struct MessageGameOver {
    let message: Message
}

/*******/
protocol MultiplayerProtocol {
    func matchEnded()
}



class MultiplayerNetworking: NSObject {
    var delegate: MultiplayerProtocol?
    
    // keep track of the random number for the local device and the ones received from the other players
    var ourRandomNumber:UInt32
    var multiplayerGameSatate: MultiplayerGameSatate
    var isPlayer1:Bool
    var receivedAllRandomNumbers:Bool
    var orderOfPlayer:[RandomNumberDetails]
    
    
    // this class keep track of the playerId and the randomNumber generated by the players devices
    class RandomNumberDetails : NSObject {
        let playerId:String
        let randomNumber:UInt32
        
        init(playerId:String, randomNumber:UInt32){
            self.playerId = playerId
            self.randomNumber = randomNumber
            super.init()
        }
        
        override func isEqual(_ object: Any?) -> Bool {
            let  randomNumberDetails = object as? RandomNumberDetails
            return randomNumberDetails?.playerId == self.playerId
        }
    }
    
    override init(){
        ourRandomNumber = arc4random()
        multiplayerGameSatate = MultiplayerGameSatate.WaitingForMatch
        isPlayer1 = false
        receivedAllRandomNumbers = false
        
        orderOfPlayer = [RandomNumberDetails]()
        
        super.init()
    }
    
    
    // network cod
    func matchStarted() {
        print("Match has started successfuly")
        
        if receivedAllRandomNumbers{
            multiplayerGameSatate = MultiplayerGameSatate.WaitingForStart
        }else{
            multiplayerGameSatate = MultiplayerGameSatate.WaitingForRandomNumber
        }
        
        sendRandomNumber()
        tryStartGame()
    }
    
    func matchEnded() {
        delegate?.matchEnded()
    }
    
    func matchReceivedData(match: GKMatch, data: Data, fromPlayer: String) {
        
    }
    
    
    func sendRandomNumber(){
        var message = MessageRandomNumber(message: Message(messageType: .RandomNumber), randomNumber: ourRandomNumber)
        
        let data = Data(bytes: &message, count: MemoryLayout<MessageRandomNumber>.size)
        sendData(data: data)
    }
    func tryStartGame(){
        // try to start the game
        if isPlayer1 && (multiplayerGameSatate == MultiplayerGameSatate.WaitingForStart){
            multiplayerGameSatate = MultiplayerGameSatate.Playing
            sendBeginGame()
        }
        
    }
    func sendData(data: Data){
        /*let gameKitHelper = GameKitHelper.sharedInstance
        
        if let multiplyerMatch = gameKitHelper.multiplayerMatch{
            // to send data across the network with the GameCenter
            do {
                try multiplyerMatch.sendData(toAllPlayers: data , with: .reliable)
            } catch {
                print(error)
                matchEnded()
            }
        }
 */
    }
    
    func sendBeginGame(){
        var message = MessageGameBegin(message: Message(messageType: .GameBegin))
        
        let data = Data(bytes: &message, count: MemoryLayout<MessageGameBegin>.size)
        sendData(data: data)
        
    }
}

